# 2.2 Основы Go

В этом разделе вы научитесь объявлять константы, переменные простых типов и ещё кое-каким навыкам программирования на Go.

## Объявление переменных

Существует несколько форм записи объявления переменных в Go.

Ключевое слово `var` является базовой формой объявления переменных, которая говорит нам, что тип переменной располагается `после` имени переменной.

	// объявление переменной с именем “variableName” и типом "type"
	var variableName type

Объявление нескольких переменных.

	// объявление трёх переменных типа "type"
	var vname1, vname2, vname3 type
	
Объявление переменной с инициализацией значения.

	// объявление переменной с именем “variableName”, типом "type" и значением "value"
	var variableName type = value
	
Объявление нескольких переменных с инициализацей значения.

	/*
    Объявление трёх переменных типа "type" и инициализацией трёх значений.
    vname1 присвоили v1, vname2 присвоили v2, vname3 присвоили v3
	*/
	var vname1, vname2, vname3 type = v1, v2, v3

Вы думаете это слишком утомительно объявлять переменные таким способом? Не волнуйтесь, потому что команда Go так же посчитала, что это может быть проблемой. Поэтому если вы хотите объявить переменные с инициализацией значениями, мы можем пропустить указание типа переменной, тогда код будет выглядеть следующим образом:

	/*
    Объявление трёх переменных без указания типа "type" и инициализация их значениями.
    vname1 присвоили v1，vname2 присвоили v2，vname3 присвоили v3
	*/
	var vname1, vname2, vname3 = v1, v2, v3

Хорошо, но я знаю, что для вас это всё ещё не достаточно просто. Давайте посмотрим как можно это исправить.	

	/*
	Объявление трёх переменных без указания типа "type", без ключевого слова "var"  и инициализация их значениями.  
    vname1 присвоили v1，vname2 присвоили v2，vname3 присвоили v3
	*/
	vname1, vname2, vname3 := v1, v2, v3
	
Сейчас это выглядит лучше. Используйте краткую форму записи `:=` вместо `var` и `type`. Однако есть одно ограничение: эту форму можно использовать только внутри функции. Вы получите ошибку компиляции, если попробуете использовать её вне тела функции. Поэтому мы обычно используем `var` для объявления глобальных переменных, так же можно использовать краткую форму в `var()`. 	

`_` (blank) - это особое имя переменной. Любое значение присвоенное ей будет проигнорировано. Для примера присвоим `35` переменной `b` и отбросим `34`. ( ***Этот пример просто показывает вам как это работает. Это выглядит бесполезно здесь, но мы часто используем этот символ когда принимаем значения возвращаемые функцией.*** ) 

	_, b := 34, 35

Если вы не используете переменные, что объявили в своей программе, компилятор выдаст вам ошибку компиляции. Попробуйте скомпилировать следующие строки кода и посмотрите, что произойдет.
	
	package main

	func main() {
	    var i int
	}
	
## Константы

Константами называются такие переменные, что были объявленны во время компиляции и значение которых нельзя изменить в течение времени выполнения. В Go вы можете использовать числа, логический и строковый типы для объявления констант.

Объявление констант выглядит следующим образом.

	const constantName = value
	// вы можете назначить тип константам, если хотите 
	const Pi float32 = 3.1415926

Ещё примеры объявления.

	const Pi = 3.1415926
	const i = 10000
	const MaxThread = 10
	const prefix = "astaxie_"
	
## Примитивные типы

### Логический тип

В Go мы используем `bool` для объявления переменных логического типа. Переменные этого типа могут иметь два значения `true` и `false`. И `false` значение по умолчанию. ( *** Вы не можете преобразовать числовую переменную в логическую и наоборот!*** )

	// пример кода
	var isActive bool  // глобальная переменная
	var enabled, disabled = true, false  // пропущен тип переменных
	func test() {
    	var available bool  // локальная переменная
    	valid := false      // краткая запись переменных
    	available = true    // присвоение значения переменной
	}
	
### Числа

Целые числа могут быть как знаковыми так и беззнаковыми. В Go есть как `int` так и `uint`, они имеют одинаковую длину, но конкретная длина зависит от вашей операционной системы. Они используют 32 бита в 32-битных операционных системах и 64 бита в 64-битных опрерационных системах. В Go так же есть типы, имеющие конкретные размеры, например: `rune`, `int8`, `int16`, `int32`, `int64`, `byte`, `uint8`, `uint16`, `uint32`, `uint64`. Отметим, что `rune` - это псевдоним `int32`, `byte` - `uint8`. 

Одна важная вещь, которую вы должны знать это то, что вы не можете присваивать значения переменных этих типов друг другу, эта операция вызовет ошибку компиляции.

	var a int8

	var b int32

	c := a + b

Хотя int32 имеет больший размер чем int8, и имеет такой же тип `int`, вы не можете присваивать значения переменных разных типов. ( *** Переменная `с` в данном случае будет объявленна как тип `int` *** )

В вещественный тип входят типы `float32` и `float64`, но не тип называемый `float`. Последний - тип по умолчанию, если вы используете краткую запись.

Это всё? Нет! Go так же поддерживает комплексные числа. `complex128` (с 64 битами в действительной и 64 битами в мнимой части) - это тип по умолчанию, если же вам нужен меньший тип, то есть тип `complex64` (с 32 битами в действительной и 32 битами в мнимой части). Это вид чисел `RE+IMi`, где `RE` - это действительная часть и `IM` - мнимая часть, последний `i` - это мнимое число. Вот пример объявления комплексного числа.

	var c complex64 = 5+5i
	//вывод: (5+5i)
	fmt.Printf("Значение: %v", c)
	
### Строки

Мы уже говорили, что в Go по умолчанию используется символы из UTF-8. Строки располагаются в двойных ковычках `""` или в обратных галочках ``` `` ```.

	// пример кода
	var frenchHello string  // простая форма объявления строк
	var emptyString string = ""  // объявление пустой строки
	func test() {
    	no, yes, maybe := "no", "yes", "maybe"  // краткая запись
    	japaneseHello := "Ohaiou"
    	frenchHello = "Bonjour"  // простая форма присвоения
	}

Невозможно изменить значение строки через индекс. Вы получите ошибки когда попробуете скомпилировать следующий код.

	var s string = "hello"
	s[0] = 'c'

Что если вы действительно хотите изменить всего один символ в строке? Попробуйте следующий код.	

	s := "hello"
	c := []byte(s)  // приведем строку к типу []byte 
	c[0] = 'c'
	s2 := string(c)  // приведём обратно к типу строки
	fmt.Printf("%s\n", s2)

Для соединения двух строк используйте `+`.	

	s := "hello,"
	m := " world"
	a := s + m
	fmt.Printf("%s\n", a)
	
и также.

	s := "hello"
	s = "c" + s[1:] // вы не можете изменять значение через индексы, но вы можете получать значения.
	fmt.Printf("%s\n", s)
	
Что если я захочу получить многострочную строку?

	m := `hello
    world`

Для этого применяются обратные галочки ` `` `.    
    
### Тип ошибок

В Go есть один тип `error` для работы с сообщениями о ошибках. Существует также пакет называемый `errors` для обработки ошибок.

	err := errors.New("emit macho dwarf: elf header corrupted")
	if err != nil {
    	fmt.Print(err)
	}
	
### Структура данных

Следующая картинка взята из статьи [Go data structure](http://research.swtch.com/godata) от [Russ Cox Blog](http://research.swtch.com/). Как вы можете видеть Go использует блочную память для хранения информации. 

![](images/2.2.basic.png?raw=true)

Рисунок 2.1 Структура данных в Go

## Полезные навыки

### Групповое объявление

Если вы хотите объявить несколько констант, переменных или импортов пакетов вы можете использовать групповую форму записи.

Простая форма записи.

	import "fmt"
	import "os"

	const i = 100
	const pi = 3.1415
	const prefix = "Go_"

	var i int
	var pi float32
	var prefix string
	
Групповая форма.

	import(
    	"fmt"
    	"os"
	)

	const(
    	i = 100
    	pi = 3.1415
    	prefix = "Go_"
	)

	var(
    	i int
    	pi float32
    	prefix string
	)

Если вы не присвоите константе значение `iota`, тогда первое значение констант в группе `const()` будет `0`. Если последующим константам явно не задавать значение, их значения будут такими же как у последнего. Если значение последней константы равно `iota`, то значение у последующих констант, которым явно не задано значение, так же будут равны `iota`.

### iota перечисления

В Go есть одно ключевое слово `iota`, это ключевое слово делает перечисления `enum`, которые начинаются с `0`, увеличиваясь на `1`.

	const(
    	x = iota  // x == 0
    	y = iota  // y == 1
    	z = iota  // z == 2
    	w  // если после объявления имени константы не будет никаких выражений, то используется последнее выражение, которое задаст w = iota. Поэтому w == 3 и в случаях с `y` и `x` так же можно было опустить "=iota". 
	)

	const v = iota // как только iota встречает ключевое слово `const`, то сразу её значение сбрасывается в `0`, так что v = 0.
	
	const ( 
	  e, f, g = iota, iota, iota // e=0,f=0,g=0 значение iota на одной строке одинаково.
	)

### Некоторые правила

Причина почему Go такой лаконичный язык в том, что он имеет ряд поведений по умолчанию.

- Любая переменная, что начинается с заглавной буквы означает, что она будет доступна из вне, иначе она приватна.
- Это же правило применимо для функций и констант, таких ключевых слов как `public` и `private` не cуществует в Go.

## массивы, срезы, и 'мапы' (array, slice, map)

### Массив (array)

Очевидно, что `array` это массив, который объявляется следующим образом.

	var arr [n]type
	
В `[n]type`, `n` - длина массива, `type` - это тип этих элементов. Как и в других языках мы используем `[]` для получения и задания элементов массива.

	var arr [10]int  // массив типа [10]int
	arr[0] = 42      // массивы индексируються с 0
	arr[1] = 13      // присвоение значения ячейке массива
	fmt.Printf("Первый элемент %d\n", arr[0])  // обращение к ячейке массива, которая вернёт нам 42
	fmt.Printf("Последний элемент %d\n", arr[9]) // обращение к 10-му элементу массива, который не был переопределён, что вернёт нам значение по умолчанию, что в данном случае равняется 0.
	
Длина массива является частью его типа, тоесть `[3]int` и `[4]int` это разные типы, это означает, что мы не можем менять длину массивов. Когда вы передаёте массивы как аргументы в функциях, происходит создание их копий, а не передача по ссылке. Если вы хотите передать их по ссылке, тогда, возможно, вы захотите использовать `slice`. Мы поговорим о них чуть позже.

Можно использовать `:=` при объявлении массивов.

	a := [3]int{1, 2, 3} // объявление массива int с тремя переменными

	b := [10]int{1, 2, 3} // объявление масcива int c 10 элементами, первые три из которого проинициализированы. Оставшиеся будут иметь значение по умолчанию 0.

	c := [...]int{4, 5, 6} // можно использовать `…` вместо явного указания длины массива, тогда Go посчитает его за вас

Вы возможно захотите использовать массивы массивов элементов. Давайте посмотрим как это сделать.

	// объявление двумерного массива с 2 элементами, каждый из которых будет содержать по 4 элемента.
	doubleArray := [2][4]int{[4]int{1, 2, 3, 4}, [4]int{5, 6, 7, 8}}

	// объявление может быть записанно в более краткой форме
	easyArray := [2][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}}
	
Внутреннее представление структуры данных массивов.

![](images/2.2.array.png?raw=true)

Рисунок 2.2 Отображение отношений в многомерных массивах

### Срезы (slice)

Во многих ситуациях тип массивов не лучший выбор. Например в случае когда мы не знаем каков будет размер массива во время его объявления. Таким образом нам нужен "динамический массив". В Go он называется `срез`.

`Срез` - это не совсем `динамический массив`. Это - ссылочный тип. `Срез` ссылается на элементы `массива` и объявляется схожим с массивами образом, за исключением того, что в срезах нам нет необходимости указывать длину.

	// так же как и объявление массива, за исключением отсутствия указания размера
	var fslice []int

Объявление `среза` и инициализация его данными.

	slice := []byte {'a', 'b', 'c', 'd'}
	
`Срезы` могут быть переопределенны существующими срезами или массивами. `Срез` использует `array[i:j]` для срезов данных, здесь `i` выступает в роли точки отсчёта, а индекс `j` для окончания, но обратите внимание на то, что `array[j]` не будет срезом, так как длина среза должна быть `j-i`.

	// объявление массива с 10 элементами типы которых байты
	var ar = [10]byte {'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}

	// объявление 2 срезов с типом []byte
	var a, b []byte

	// 'a' ссылается на элементы начиная с 3-го по 5-ый из массива ar.
	a = ar[2:5]
	// сейчас 'a' содержит элементы ar[2],ar[3] и ar[4]

	// 'b' это другой срез массива ar
	b = ar[3:5]
	// сейчас 'b' содержит элементы ar[3] и ar[4]

Обращаю ваше внимание на разницу между `срезом` и `массивом`, когда вы объявляете их. Мы используем `[...]` для того чтобы Go сама подсчитала длину массива, но `[]` используется только для объявления среза. 	

Внутреннее представление структуры этих данных.

![](images/2.2.slice.png?raw=true)

Рисунок 2.3 Отношения между срезами и массивом

У срезов есть некоторые удобные операции.

- Индексация `среза` начинается с 0-го элемента, `ar[:n]` равнозначна `ar[0:n]`
- Второй индекс определяющий длину среза может быть опущен, если вы хотите получить срез до конца массива, `ar[n:]` равнозначно `ar[n:len(ar)]`.
- Вы можете использовать `ar[:]` для среза целого массива, по причинам описаным в первых двух пунктах.

Больше примеров относящихся к `срезам`

	// объявление массива
	var array = [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
	// объявление двух срезов
	var aSlice, bSlice []byte

	// некоторые удобные операции
	aSlice = array[:3] // равнозначно aSlice = array[0:3]  aSlice содержит элементы a,b,c
	aSlice = array[5:] // равнозначно aSlice = array[5:10] aSlice содержит элементы f,g,h,i,j
	aSlice = array[:]  // равнозначно aSlice = array[0:10] aSlice содержит все элементы

	// срез от среза
	aSlice = array[3:7]  // aSlice содержит d,e,f,g，len=4，cap=7
	bSlice = aSlice[1:3] // bSlice содержит aSlice[1], aSlice[2], тоесть содержит элементы e,f
	bSlice = aSlice[:3]  // bSlice содержит aSlice[0], aSlice[1], aSlice[2], тоесть содержит элементы d,e,f
	bSlice = aSlice[0:5] // срезы можно расширять, теперь bSlice содержит d,e,f,g,h
	bSlice = aSlice[:]   // bSlice содержит те же элементы, что и aSlice, тоесть d,e,f,g

`Срезы` - это ссылочный тип, так что любые изменения будут влиять на другие переменные ссылающиеся на этот срез или массив. Например, в случае выше с `aSlice` и `bSlice`, если вы измените значение элементов `aSlice`, тогда `bSlice` тоже измениться.

`Срез` похожа на структуру по определению, которая состоит из 3 частей.

- Указатель откуда срез начинается.
- Длину среза.
- Ёмкость, длина от начального индекса до конечного индекса `среза`.

		Array_a := [10]byte{'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'}
		Slice_a := Array_a[2:5]

Внутреннее представление структуры данных кода представленного выше.

![](images/2.2.slice2.png?raw=true)

Рисунок 2.4 Внутреннее представление данных среза

Есть несколько встроенных функций для среза.

- `len` возвращает длину `среза`.
- `cap` возвращает максимальную длину `среза`.
- `append` добавляет один или больше элементов в `срез`, и возвращает `срез`.
- `copy` копирует элементы из одного среза в другой, и возвращает число элементов, что были скопированны.

Внимание: `append` изменит массив на который `срез` ссылается и влияет на другие срезы, что ссылаются на тот же массив. Так же если срезу не хватает длины (`(cap-len) == 0`), `append` возвращает новый массив для среза. Однако когда это происходит остальные срезы, ссылающиеся на старый массив, не будут изменены.

### map

`map` похожи на словари из Python. Объявляются следующим образом `map[keyType]valueType`.

Давайте рассмотрим пример кода. Назначение и получение значений в `map` похожи на `срезы`, однако индекс в `срезах` может быть только целого типа `int`, а в `map` можно использовать и другие типы. Например `int`, `string` или что вам захочется. Конечно, если они способны использовать `==` и `!=` для сравнения значений.

	// строка как тип ключа, строка как тип значения map'a и инициализация с помощью `make`.
	var numbers map[string] int
	// другой способ объявления map
	numbers := make(map[string]int)
	numbers["one"] = 1  // присвоение значения по ключу
	numbers["ten"] = 10 
	numbers["three"] = 3

	fmt.Println("Третье число это: ", numbers["three"]) // получить значения
	// Это выведет: Третье число это: 3

Некоторые замечания по использованию `map`.

- `map` "беспорядочный" тип данных. Каждый раз когда вы будете выводить `map`, вы будете получать разные результаты. Не возможно получить значения через `индексы` - вы должны использовать `ключи`.
- `map` не имеет фиксированной длины.  Это ссылочный тип так же как и `срез`.
- `len` так же работает для `map`. Она возвращает как много `ключей` в map'e.
- Очень просто изменить значения через `map`. Для этого просто пишите `numbers["one"]=11` это изменит значение `ключа` на `11`.

Вы можете использовать запись `key:val` для инициализации значений map'a и в map'e есть встроенные методы для проверки существования `ключа`.

Используйте `delete` для удаления элементов из `map`.

	// инициализация map
	rating := map[string]float32 {"C":5, "Go":4.5, "Python":4.5, "C++":2 }
	// map имеет два возвращаемых значения. Для второго возвращаемого значения, если ключ не существует, 'ok' вернёт false, иначе true.
	csharpRating, ok := rating["C#"]
	if ok {
    	fmt.Println("C# присутствует в map'e и его рейтинг ", csharpRating)
	} else {
    fmt.Println("У нас нет рейтинга для C# в map'e")
	}

	delete(rating, "C")  // удалить элемент с ключом "c"

Как я сказал ранее `map` ссылочного типа. Если два `map'a` ссылаются на одну и ту же информацию, любое изменение её будет влиять на них обоих. 

	m := make(map[string]string)
	m["Hello"] = "Bonjour"
	m1 := m
	m1["Hello"] = "Salut"  // сейчас значение m["hello"] равняется Salut
	
### make, new

`make` делает выделение памяти для встроенных моделей, таких как `map`, `slice`, и `channel`, а `new` для выделение памяти типам.

`new(T)` выделяет память для типа `T`, инициализирует её нулевыми значениями, возвращает адрес этой памяти, который содержит элемент типа `*T`. Что по определению в Go значит, что она возвращает указатель, который ссылается на нулевой элемент типа `T`.

`new` возвращает указатели.

Встроенная функция `make(T, args)` имеет отличное от `new(T)` назначение. `make` может быть использована для `slice`, `map`, и `channel`. Она возвращает тип `T` с начальным значеним. Причиной для этого может служить, то, что внутренне представление этих трёх типов может быть проинициализировано до того как на них будут ссылаться. Для примера `срез` содержит указатель, который указывает на внутренне представление `массива`, длину и ёмкость. Прежде чем эти данные будут проинициализированны, `slice` будет `nil`, так что для `slice`, `map` и `channel`, `make` инициализирует их внутренне представление и присваивает какие-то подходящие значения.

`make` возвращает на нулевое значение.

Следующая картинка показывает как `new` и `make` отличаются.

![](images/2.2.makenew.png?raw=true)

Рисунок 2.5 Внутренне представление выделения памяти с помощью make и new

Нулевое значение не означает пустое значение. Это значение по умолчанию в большинстве случаев. Вот список некоторых нулевых значений.

	int     0
	int8    0
	int32   0
	int64   0
	uint    0x0
	rune    0 // фактически rune это тип int32
	byte    0x0 // фактически byte это тип uint8 
	float32 0 // длина 4 byte
	float64 0 //длина 8 byte
	bool    false
	string  ""
	
## Ссылки

- [Содержание](preface.md)
- Предыдущий раздел: ["Hello, Go"](02.1.md)
- Следующий раздел: [Управляющие конструкции и функции](02.3.md)
